# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VkowldIhXLoI0RJyPe40v0xlUuFt26BR
"""

import subprocess
import os
import sys
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Draw
import tempfile

def install_xtb():
    """Install xTB in Google Colab"""
    print("Installing xTB...")
    try:
        # Install xTB using conda
        subprocess.run([
            "wget", "https://github.com/grimme-lab/xtb/releases/download/v6.6.0/xtb-6.6.0-linux-x86_64.tar.xz"
        ], check=True)
        subprocess.run(["tar", "-xf", "xtb-6.6.0-linux-x86_64.tar.xz"], check=True)
        subprocess.run(["cp", "-r", "xtb-6.6.0", "/usr/local/"], check=True)
        subprocess.run(["ln", "-sf", "/usr/local/xtb-6.6.0/bin/xtb", "/usr/local/bin/xtb"], check=True)
        subprocess.run(["ln", "-sf", "/usr/local/xtb-6.6.0/lib", "/usr/local/lib/xtb"], check=True)

        # Add to PATH
        os.environ['PATH'] = '/usr/local/xtb-6.6.0/bin:' + os.environ['PATH']
        os.environ['XTBPATH'] = '/usr/local/xtb-6.6.0'

        print("‚úì xTB —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ!")
        return True
    except Exception as e:
        print(f"‚úó –æ—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ xTB: {e}")
        return False
def check_xtb_installation():
    """Check if xTB is installed and available"""
    try:
        result = subprocess.run(["which", "xtb"], capture_output=True, text=True)
        if result.returncode == 0:
            print("‚úì xTB —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
            return True
        else:
            print("xTB –Ω–µ –Ω–∞–π–¥–µ–Ω, —É—Å—Ç–∞–Ω–æ–≤–∫–∞...")
            return install_xtb()
    except Exception as e:
        print(f"Error checking xTB installation: {e}")
        return install_xtb()

def smiles_to_xtb_calculation(smiles, calculation_type='sp', charge=0, spin=1,
                            solvent=None, output_dir="."):
    """
    Convert SMILES to 3D geometry and run xtb calculations

    Parameters:
    - smiles: SMILES string
    - calculation_type: 'sp' for single-point, 'opt' for optimization, 'freq' for frequency
    - charge: molecular charge
    - spin: spin multiplicity (1 for singlet, 2 for doublet, etc.)
    - solvent: solvent for GBSA model (e.g., 'water', 'methanol')
    - output_dir: output directory
    """

    # First check if xTB is installed
    if not check_xtb_installation():
        raise RuntimeError("xTB is not available. Please install it manually.")

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    # Generate molecule from SMILES
    print(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ SMILES: {smiles}")
    mol = Chem.MolFromSmiles(smiles)

    if mol is None:
        raise ValueError(f"–ü–ª–æ—Ö–æ –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π SMILES: {smiles}")

    # Add hydrogens
    mol = Chem.AddHs(mol)

    # Generate 3D coordinates
    print("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç...")
    AllChem.EmbedMolecule(mol, randomSeed=42)

    # Optimize with MMFF94
    print("–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Å MMFF94...")
    AllChem.MMFFOptimizeMolecule(mol)

    # Generate molecule name from SMILES
    mol_name = smiles.replace('/', '_').replace('\\', '_')[:20]

    # Save as XYZ file
    xyz_file = os.path.join(output_dir, f"{mol_name}.xyz")

    # Write XYZ file
    with open(xyz_file, 'w') as f:
        f.write(f"{mol.GetNumAtoms()}\n")
        f.write(f"–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ –∏–∑ SMILES: {smiles}\n")

        conf = mol.GetConformer()
        for i, atom in enumerate(mol.GetAtoms()):
            pos = conf.GetAtomPosition(i)
            symbol = atom.GetSymbol()
            f.write(f"{symbol} {pos.x:.6f} {pos.y:.6f} {pos.z:.6f}\n")

    print(f"–ì–µ–º–µ—Ç—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤: {xyz_file}")

    # Save molecule image
    img_file = os.path.join(output_dir, f"{mol_name}.png")
    img = Draw.MolToImage(mol, size=(300, 300))
    img.save(img_file)
    print(f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –º–æ–ª–µ–∫—É–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ : {img_file}")

    # Display molecule image in Colab
    try:
        from IPython.display import display
        display(img)
    except:
        pass

    # Run xtb calculations
    if calculation_type == 'sp':
        return run_xtb_single_point(xyz_file, charge, spin, solvent, output_dir)
    elif calculation_type == 'opt':
        return run_xtb_optimization(xyz_file, charge, spin, solvent, output_dir)
    elif calculation_type == 'freq':
        return run_xtb_frequency(xyz_file, charge, spin, solvent, output_dir)
    else:
        raise ValueError("calculation_type must be 'sp', 'opt', or 'freq'")

def run_xtb_single_point(xyz_file, charge=0, spin=1, solvent=None, output_dir="."):
    """Run single-point energy calculation"""
    print("–ù–∞—á–∏–Ω–∞–µ–º single-point —Ä–∞—Å—Å—á–µ—Ç —ç–Ω–µ—Ä–≥–∏–∏...")

    # Use list-based command for better security and compatibility
    cmd = ["xtb", os.path.basename(xyz_file), "--sp", "--chrg", str(charge), "--uhf", str(spin-1)]

    if solvent:
        # Fix potential typo in solvent name
        if solvent.lower() == "mathanol":
            solvent = "methanol"
            print(f"Note: Changed solvent from 'mathanol' to 'methanol'")
        cmd.extend(["--gbsa", solvent])

    print(f"Command: {' '.join(cmd)}")

    # Change to output directory and run command
    original_dir = os.getcwd()
    os.chdir(output_dir)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        # Save output
        log_file = "single_point.log"
        with open(log_file, "w") as f:
            f.write(result.stdout)

        if result.returncode == 0:
            print("‚úì Single-point —Ä–∞—Å—Å—á–µ—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã!")
            print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤: {log_file}")
            return parse_xtb_output(result.stdout)
        else:
            print("‚úó Single-point calculation failed!")
            print(f"Error: {result.stderr}")
            # Also print the full output for debugging
            print("Full output:")
            print(result.stdout)
            return None
    finally:
        os.chdir(original_dir)

def run_xtb_optimization(xyz_file, charge=0, spin=1, solvent=None, output_dir="."):
    """Run geometry optimization"""
    print("Running geometry optimization...")

    cmd = ["xtb", os.path.basename(xyz_file), "--opt", "--chrg", str(charge), "--uhf", str(spin-1)]

    if solvent:
        if solvent.lower() == "mathanol":
            solvent = "methanol"
            print(f"Note: Changed solvent from 'mathanol' to 'methanol'")
        cmd.extend(["--gbsa", solvent])

    print(f"Command: {' '.join(cmd)}")

    # Change to output directory and run command
    original_dir = os.getcwd()
    os.chdir(output_dir)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        # Save output
        log_file = "optimization.log"
        with open(log_file, "w") as f:
            f.write(result.stdout)

        if result.returncode == 0:
            print("‚úì Optimization completed!")
            optimized_file = "xtbopt.xyz"
            if os.path.exists(optimized_file):
                print(f"Optimized geometry: {optimized_file}")
            print(f"Output saved to: {log_file}")
            return parse_xtb_output(result.stdout)
        else:
            print("‚úó Optimization failed!")
            print(f"Error: {result.stderr}")
            print("Full output:")
            print(result.stdout)
            return None
    finally:
        os.chdir(original_dir)

def run_xtb_frequency(xyz_file, charge=0, spin=1, solvent=None, output_dir="."):
    """Run frequency calculation"""
    print("Running frequency calculation...")

    cmd = ["xtb", os.path.basename(xyz_file), "--hess", "--chrg", str(charge), "--uhf", str(spin-1)]

    if solvent:
        if solvent.lower() == "mathanol":
            solvent = "methanol"
            print(f"Note: Changed solvent from 'mathanol' to 'methanol'")
        cmd.extend(["--gbsa", solvent])

    print(f"Command: {' '.join(cmd)}")

    # Change to output directory and run command
    original_dir = os.getcwd()
    os.chdir(output_dir)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        # Save output
        log_file = "frequency.log"
        with open(log_file, "w") as f:
            f.write(result.stdout)

        if result.returncode == 0:
            print("‚úì Frequency calculation completed!")
            print(f"Output saved to: {log_file}")
            return parse_xtb_output(result.stdout)
        else:
            print("‚úó Frequency calculation failed!")
            print(f"Error: {result.stderr}")
            print("Full output:")
            print(result.stdout)
            return None
    finally:
        os.chdir(original_dir)

def parse_xtb_output(output):
    """Parse xtb output to extract total energy and HOMO-LUMO gap"""
    results = {}

    lines = output.split('\n')

    for i, line in enumerate(lines):
        # Parse TOTAL ENERGY (from the box at the end)
        if 'TOTAL ENERGY' in line:
            try:
                # Extract energy value from lines like:
                # "| TOTAL ENERGY              -11.393351577127 Eh   |"
                parts = line.split()
                for j, part in enumerate(parts):
                    if part == 'ENERGY':
                        energy_str = parts[j+1]  # Should be the energy value
                        results['total_energy'] = float(energy_str)
                        results['energy_units'] = 'Eh'  # Hartree
                        break
            except (ValueError, IndexError):
                pass

        # Parse HOMO-LUMO GAP (from the box at the end)
        elif 'HOMO-LUMO GAP' in line:
            try:
                # Extract gap value from lines like:
                # "| HOMO-LUMO GAP              12.525947406591 eV   |"
                parts = line.split()
                for j, part in enumerate(parts):
                    if part == 'GAP':
                        gap_str = parts[j+1]  # Should be the gap value
                        results['homo_lumo_gap'] = float(gap_str)
                        results['gap_units'] = 'eV'
                        break
            except (ValueError, IndexError):
                pass

        # Alternative parsing for HOMO-LUMO gap from the orbital section
        elif 'HL-Gap' in line:
            try:
                # Extract from lines like:
                # "HL-Gap            0.4603201 Eh           12.5259 eV"
                parts = line.split()
                # The gap in eV is usually the last numeric value
                for part in reversed(parts):
                    try:
                        gap_value = float(part)
                        # Check if this is likely the eV value (reasonable range for gaps)
                        if 0.1 < gap_value < 50.0:
                            results['homo_lumo_gap'] = gap_value
                            results['gap_units'] = 'eV'
                            break
                    except ValueError:
                        continue
            except (ValueError, IndexError):
                pass

        # Alternative parsing for total energy (from earlier in the output)
        elif 'total energy' in line.lower() and 'total_energy' not in results:
            try:
                # Extract from lines like: "total energy  :        -11.393351577127 Eh"
                parts = line.split()
                for j, part in enumerate(parts):
                    if part.lower() == 'energy':
                        energy_str = parts[j+2]  # Usually two parts after "energy"
                        results['total_energy'] = float(energy_str)
                        results['energy_units'] = parts[j+3]
                        break
            except (ValueError, IndexError):
                pass

    # If we found both values, also calculate the gap in Hartree for consistency
    if 'total_energy' in results and 'homo_lumo_gap' in results:
        # Convert eV to Hartree (1 eV = 0.0367493 Hartree)
        results['homo_lumo_gap_hartree'] = results['homo_lumo_gap'] * 0.0367493

    return results

def run_calculation_interactive(smiles = None):
    """Interactive function for Google Colab - gets input from user"""

    print("=" * 60)
    print("xTB Calculation from SMILES")
    print("=" * 60)
    
    # First check and install xTB if needed
    if not check_xtb_installation():
        print("Failed to install xTB. Please install it manually.")
        return

    # Interactive input for Colab
    # smiles = input("–í–≤–µ–¥–∏—Ç–µ SMILES —Å—Ç—Ä–æ–∫—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, CCO –¥–ª—è —ç—Ç–∞–Ω–æ–ª–∞): ").strip()

    calculation = 'sp'

    charge = 0

    spin = 1

    # solvent = input("Solvent for GBSA model (e.g., water, methanol) [optional]: ").strip()
    # if not solvent:
    solvent = None

    
    output_dir = "./output/" + str(smiles) + "/"
    print (f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—Å—á–µ—Ç–∞ –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {output_dir}")

    try:
        # Run the calculation
        results = smiles_to_xtb_calculation(
            smiles=smiles,
            calculation_type=calculation,
            charge=charge,
            spin=spin,
            solvent=solvent,
            output_dir=output_dir
        )

        # Print results
        if results:
            print("\n" + "="*50)
            print("–†–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")
            print("="*50)
            for key, value in results.items():
                print(f"{key}: {value}")

            # Create a simple summary
            print("\n" + "="*50)
            print("SUMMARY")
            print("="*50)
            if 'total_energy' in results:
                print(f"–û–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è: {results['total_energy']:.6f} {results.get('energy_units', 'Eh')}")
            if 'homo_lumo_gap' in results:
                print(f"HOMO-LUMO –ø–µ—Ä–µ—Ö–æ–¥: {results['homo_lumo_gap']:.4f} {results.get('gap_units', 'eV')}")
            return results
        else:
            print("No results obtained from calculation")

    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()

# For Google Colab compatibility
if __name__ == "__main__":
    # Check if we're in a notebook environment
    try:
        from IPython import get_ipython
        if 'IPKernelApp' in get_ipython().config:
            print("Running in Jupyter/Colab environment")
            # You can call run_calculation_interactive() directly in Colab
    except:
        print("Running in standard Python environment")
        run_calculation_interactive()

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

def gap_to_wavenumber_and_color(gap_hartree):
    """
    Convert HOMO-LUMO gap from Hartree to wavenumber (cm‚Åª¬π) and approximate color
    """
    # Constants for conversion
    HARTREE_TO_JOULE = 4.3597447222071e-18
    PLANCK_CONSTANT = 6.62607015e-34
    SPEED_OF_LIGHT = 2.99792458e10  # cm/s

    # Convert Hartree to Joules
    gap_joules = gap_hartree * HARTREE_TO_JOULE

    # Convert energy to frequency (Hz)
    frequency_hz = gap_joules / PLANCK_CONSTANT

    # Convert frequency to wavenumber (cm‚Åª¬π)
    wavenumber_cm1 = frequency_hz / SPEED_OF_LIGHT

    # Convert wavenumber to wavelength (nm)
    if wavenumber_cm1 > 0:
        wavelength_nm = 1e7 / wavenumber_cm1
    else:
        wavelength_nm = 0

    # Get RGB color (handle IR/UV regions properly)
    rgb_color, color_info = get_color_with_extended_range(wavelength_nm)

    return {
        'gap_hartree': gap_hartree,
        'gap_ev': gap_hartree / 0.0367493,
        'wavenumber_cm1': wavenumber_cm1,
        'wavelength_nm': wavelength_nm,
        'rgb_color': rgb_color,
        'color_region': color_info['region'],
        'visible': color_info['visible']
    }

def get_color_with_extended_range(wavelength_nm):
    """
    Get color with proper handling of IR and UV regions
    """
    if wavelength_nm <= 0:
        return (0, 0, 0), {'region': 'Invalid', 'visible': False}

    # Extended wavelength ranges with meaningful colors
    if wavelength_nm < 10:  # Gamma rays, X-rays
        return (128, 0, 128), {'region': 'Gamma/X-ray', 'visible': False}
    elif 10 <= wavelength_nm < 200:  # Extreme UV
        return (75, 0, 130), {'region': 'Extreme UV', 'visible': False}
    elif 200 <= wavelength_nm < 380:  # UV
        # Gradient from violet to blue in UV
        factor = (wavelength_nm - 200) / (380 - 200)
        r = int(128 * factor)
        g = 0
        b = int(128 + 127 * factor)
        return (r, g, b), {'region': 'UV', 'visible': False}
    elif 380 <= wavelength_nm <= 780:  # Visible
        rgb = wavelength_to_rgb_piecewise(wavelength_nm)
        return rgb, {'region': 'Visible', 'visible': True}
    elif 780 < wavelength_nm <= 2500:  # Near IR
        # Gradient from red to black in IR
        factor = 1.0 - min(1.0, (wavelength_nm - 780) / (2500 - 780))
        r = int(255 * factor)
        g = 0
        b = 0
        return (r, g, b), {'region': 'Near IR', 'visible': False}
    elif 2500 < wavelength_nm <= 25000:  # Mid IR
        # Dark red to black
        factor = 1.0 - min(1.0, (wavelength_nm - 2500) / (25000 - 2500))
        r = int(128 * factor)
        g = 0
        b = 0
        return (r, g, b), {'region': 'Mid IR', 'visible': False}
    else:  # Far IR, microwave, radio
        return (64, 64, 64), {'region': 'Far IR/Radio', 'visible': False}

def wavelength_to_rgb_piecewise(wavelength_nm):
    """Convert wavelength to RGB (visible spectrum only)"""
    if wavelength_nm < 380 or wavelength_nm > 780:
        return (0, 0, 0)

    wavelength = float(wavelength_nm)

    if wavelength >= 380 and wavelength <= 440:
        r = -(wavelength - 440) / (440 - 380)
        g = 0.0
        b = 1.0
    elif wavelength >= 440 and wavelength <= 490:
        r = 0.0
        g = (wavelength - 440) / (490 - 440)
        b = 1.0
    elif wavelength >= 490 and wavelength <= 510:
        r = 0.0
        g = 1.0
        b = -(wavelength - 510) / (510 - 490)
    elif wavelength >= 510 and wavelength <= 580:
        r = (wavelength - 510) / (580 - 510)
        g = 1.0
        b = 0.0
    elif wavelength >= 580 and wavelength <= 645:
        r = 1.0
        g = -(wavelength - 645) / (645 - 580)
        b = 0.0
    elif wavelength >= 645 and wavelength <= 780:
        r = 1.0
        g = 0.0
        b = 0.0
    else:
        r = 0.0
        g = 0.0
        b = 0.0

    # Intensity correction
    if wavelength >= 380 and wavelength < 420:
        factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380)
    elif wavelength >= 420 and wavelength < 701:
        factor = 1.0
    elif wavelength >= 701 and wavelength <= 780:
        factor = 0.3 + 0.7 * (780 - wavelength) / (780 - 700)
    else:
        factor = 0.0

    r = int(255 * r * factor)
    g = int(255 * g * factor)
    b = int(255 * b * factor)

    return (max(0, min(255, r)), max(0, min(255, g)), max(0, min(255, b)))

def display_single_color(rgb, color_name="Color", size=(5, 2), save_path = None):
    """
    Display a single color with RGB values
    """
    print (f"–¢–≤–æ–π RGB –≤–µ–∫—Ç–æ—Ä - {rgb}")
    # Create figure
    fig, ax = plt.subplots(1, 1, figsize=size)

    # Convert RGB to 0-1 range for matplotlib
    rgb_normalized = [x/255 for x in rgb]

    # Create a simple rectangle with the color
    ax.add_patch(plt.Rectangle((0, 0), 1, 1, color=rgb_normalized))

    # Set up the plot
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_aspect('equal')
    ax.axis('off')

    # Add text with RGB values
    # ax.text(0.5, 0.5, f'–¢–≤–æ–π RGB –≤–µ–∫—Ç–æ—Ä —Ü–≤–µ—Ç–∞ - {rgb}',
    #        ha='center', va='center', fontsize=12,
    #        color='white' if sum(rgb) < 380 else 'black',
    #        weight='bold')
    ax.set_title(f'–¢–≤–æ–π RGB –≤–µ–∫—Ç–æ—Ä —Ü–≤–µ—Ç–∞ - {rgb}', 
             fontsize=10,  # –†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∞
             color='black',  # –¶–≤–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∞
             weight='bold',  # –ñ–∏—Ä–Ω–æ—Å—Ç—å
             pad=20)  # –û—Ç—Å—Ç—É–ø –æ—Ç –≥—Ä–∞—Ñ–∏–∫–∞

    plt.tight_layout()

    if save_path:
        # Create directory if it doesn't exist
        # os.makedirs(os.path.dirname(save_path) if os.path.dirname(save_path) else '.', exist_ok=True)
        # Save the figure
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"–ö–∞—Ä—Ç–∏–Ω–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤: {save_path}")

    plt.show()

def save_name_tuple(name, tuple_data, filename="data.txt"):
    """
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–∞—Ä—É name:tuple –≤ —Ñ–∞–π–ª
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
        if not os.path.exists(filename):
            print(f"–§–∞–π–ª '{filename}' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π.")
        
        with open(filename, 'a', encoding='utf-8') as file:
            file.write(f"{name}: {tuple_data}\n")
        print(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {name}: {tuple_data}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")

def parse_colors(filename="colors.txt"):
    """
    –ü–∞—Ä—Å–∏—Ç —Ñ–∞–π–ª –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å {–∏–º—è: –∫–æ—Ä—Ç–µ–∂_RGB}
    –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è - –∫–æ—Ä—Ç–µ–∂–∏ –∏–∑ 3 —á–∏—Å–µ–ª
    """
    colors_dict = {}
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            for line_num, line in enumerate(file, 1):
                line = line.strip()
                if line and ':' in line:
                    name, tuple_str = line.split(':', 1)
                    name = name.strip()
                    tuple_str = tuple_str.strip()
                    
                    try:
                        # –ü–∞—Ä—Å–∏–º –∫–æ—Ä—Ç–µ–∂
                        parsed_data = ast.literal_eval(tuple_str)
                        
                        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ tuple –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                        if not isinstance(parsed_data, tuple):
                            parsed_data = tuple(parsed_data)
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –∫–æ—Ä—Ç–µ–∂ –∏–∑ 3 —á–∏—Å–µ–ª
                        if (isinstance(parsed_data, tuple) and 
                            len(parsed_data) == 3 and 
                            all(isinstance(x, (int, float)) for x in parsed_data)):
                            
                            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                            rgb_tuple = tuple(int(x) for x in parsed_data)
                            colors_dict[name] = rgb_tuple
                        else:
                            print(f"–ü—Ä–æ–ø—É—â–µ–Ω–∞ —Å—Ç—Ä–æ–∫–∞ {line_num}: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç RGB")
                            
                    except (ValueError, SyntaxError) as e:
                        print(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤ —Å—Ç—Ä–æ–∫–µ {line_num}: {e}")
                        continue
                        
        return colors_dict
    except FileNotFoundError:
        print(f"–§–∞–π–ª {filename} –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return {}
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: {e}")
        return {}
        
log_file_name = os.path.join("./output/", "log")

def homo_lumo_color():
    smiles = input("–í–≤–µ–¥–∏—Ç–µ SMILES —Å—Ç—Ä–æ–∫—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, CCO –¥–ª—è —ç—Ç–∞–Ω–æ–ª–∞): ").strip()
    res = run_calculation_interactive(smiles)
    re = gap_to_wavenumber_and_color(res["homo_lumo_gap_hartree"])

    save_name_tuple(smiles, re['rgb_color'], filename = log_file_name)
    
    display_single_color(re['rgb_color'], save_path = os.path.join("./output/", smiles))
    return re['rgb_color']
# -*- coding: utf-8 -*-
"""Stable Diffusion —Å –≤—ã–±–æ—Ä–æ–º –º–æ–¥–µ–ª–µ–π"""

import torch
import time
import matplotlib.pyplot as plt
from google.colab import files
import gc

# –û—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏
if torch.cuda.is_available():
    torch.cuda.empty_cache()
gc.collect()

# –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
MODELS = {
    "4": {
        "name": "DreamShaper (–£–ù–ò–í–ï–†–°–ê–õ–¨–ù–ê–Ø)",
        "id": "lykon/dreamshaper-8",
        "type": "stable_diffusion"
    }
}

def load_model(model_choice="1"):
    """–ó–∞–≥—Ä—É–∑–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏"""
    model_info = MODELS[model_choice]
    print(f"üöÄ –ó–∞–≥—Ä—É–∑–∫–∞: {model_info['name']}")
    print(f"üìÅ –ú–æ–¥–µ–ª—å: {model_info['id']}")

    try:
        from diffusers import StableDiffusionPipeline

        pipe = StableDiffusionPipeline.from_pretrained(
            model_info["id"],
            torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32,
            safety_checker=None,
            requires_safety_checker=False
        )

        if torch.cuda.is_available():
            pipe = pipe.to("cuda")
            pipe.enable_attention_slicing()
            print("‚úÖ –ú–æ–¥–µ–ª—å –Ω–∞ GPU —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π")
        else:
            pipe = pipe.to("cpu")
            print("‚ö†Ô∏è  –ú–æ–¥–µ–ª—å –Ω–∞ CPU - –±—É–¥–µ—Ç –º–µ–¥–ª–µ–Ω–Ω–æ")

        print(f"‚úÖ {model_info['name']} –∑–∞–≥—Ä—É–∂–µ–Ω–∞!")
        return pipe

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ {model_info['name']}: {e}")
        print("üîÑ –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –±–∞–∑–æ–≤—É—é –º–æ–¥–µ–ª—å...")

        # –ü—Ä–æ–±—É–µ–º –±–∞–∑–æ–≤—É—é –º–æ–¥–µ–ª—å –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
        from diffusers import StableDiffusionPipeline
        pipe = StableDiffusionPipeline.from_pretrained("runwayml/stable-diffusion-v1-5")
        pipe = pipe.to("cuda" if torch.cuda.is_available() else "cpu")
        return pipe



# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ç–µ–∫—É—â–µ–π –º–æ–¥–µ–ª–∏
pipe = None

def initialize_generator():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —Å –≤—ã–±–æ—Ä–æ–º –º–æ–¥–µ–ª–∏"""
    global pipe

    while True:
        choice = "4".strip()

        if choice in MODELS:
            pipe = load_model(choice)
            if pipe is not None:
                return
        else:
            print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")

def generate_with_progress(prompt, steps=20):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º"""
    global pipe

    if pipe is None:
        print("‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞! –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞.")
        return None

    print(f"üé® –ó–∞–ø—Ä–æ—Å: '{prompt}'")
    print(f"üî¢ –®–∞–≥–æ–≤: {steps}")
    print("‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è...", end=" ")

    start_time = time.time()

    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    result = pipe(
        prompt=prompt,
        num_inference_steps=steps,
        guidance_scale=7.5,
        width=512,
        height=512
    )

    end_time = time.time()
    generation_time = end_time - start_time

    print(f"‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {generation_time:.1f} —Å–µ–∫—É–Ω–¥")

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å –∏–º–µ–Ω–µ–º –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    filename = input("üíæ –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–±–µ–∑ .png): ").strip()
    if not filename:
        filename = f"image_{int(time.time())}"

    filename += ".png"
    result.images[0].save(filename)
    print(f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫: {filename}")

    return result.images[0]

# –ü—Ä–∏–º–µ—Ä—ã –ø—Ä–æ–º–ø—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
EXAMPLE_PROMPTS = {
    "4": [
        "—Ñ—ç–Ω—Ç–µ–∑–∏–π–Ω—ã–π –ø–µ–π–∑–∞–∂ —Å –¥—Ä–∞–∫–æ–Ω–æ–º –∏ –∑–∞–º–∫–æ–º, —ç–ø–∏—á–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ",
        "–∞–Ω–∏–º–µ –¥–µ–≤—É—à–∫–∞ —Å —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–º–∏ –≤–æ–ª–æ—Å–∞–º–∏ –≤ –º–∞–≥–∏—á–µ—Å–∫–æ–º –ª–µ—Å—É",
        "–∫–∏–±–µ—Ä–ø–∞–Ω–∫ —É–ª–∏—Ü–∞ –Ω–æ—á—å—é, –¥–æ–∂–¥—å, –Ω–µ–æ–Ω–æ–≤–∞—è —Ä–µ–∫–ª–∞–º–∞"
    ]
}

def main_interface():
    """–ì–ª–∞–≤–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–æ–≥—Ä–∞–º–º—ã"""
    global pipe

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏
    initialize_generator()

    current_model = None
    for key, model in MODELS.items():
        if "dreamshaper" in model["id"].lower() and isinstance(pipe, type(pipe)):
            current_model = key
            break

    if current_model is None:
        current_model = "1"

    print(f"\n‚ú® –¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å: {MODELS[current_model]['name']}")

    while True:
        print("\n" + "="*40)
        print("üé® –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ")
        print("="*40)

        choice = input(
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\n"
            "1 - –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n"
            "2 - –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∏–º–µ—Ä—ã –¥–ª—è —Ç–µ–∫—É—â–µ–π –º–æ–¥–µ–ª–∏\n"
            "3 - –í—ã—Ö–æ–¥\n"
            "> "
        ).strip()

        if choice == "1":
            prompt = input("üìù –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ").strip()
            if not prompt:
                print("‚ùå –û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
                continue

            try:
                steps = int(input("üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ (–æ—Ç 15): ") or "20")
                steps = max(15, steps)
            except:
                steps = 20

            image = generate_with_progress(prompt, steps)

            if image:
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                plt.figure(figsize=(10, 8))
                plt.imshow(image)
                plt.axis('off')
                plt.title(f'"{prompt}"', pad=20)
                plt.tight_layout()
                plt.show()



        elif choice == "2":
            print(f"\nüöÄ –ü—Ä–∏–º–µ—Ä—ã –¥–ª—è {MODELS[current_model]['name']}:")
            for i, example in enumerate(EXAMPLE_PROMPTS[current_model], 1):
                print(f"{i}. {example}")


        elif choice == "3":
            print("üëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!")
            break

        else:
            print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä")

import numpy as np
from PIL import Image

def quick_color_restore(image_path, colors_to_restore):
    """
    –ë—ã—Å—Ç—Ä–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ü–≤–µ—Ç–æ–≤ –∑–∞ –æ–¥–∏–Ω —Ä–∞–∑
    
    Args:
        image_path (str): –ø—É—Ç—å –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
        colors_to_restore (dict): —Å–ª–æ–≤–∞—Ä—å —Å —Ü–≤–µ—Ç–∞–º–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –∏–º—è:–∫–æ—Ä—Ç–µ–∂_RGB
    """
    original_img = Image.open(image_path).convert('RGB')
    img_array = np.array(original_img)
    
    # –°–æ–∑–¥–∞–µ–º —á–µ—Ä–Ω–æ-–±–µ–ª—É—é –≤–µ—Ä—Å–∏—é
    bw_array = np.dot(img_array[...,:3], [0.0, 0.0, 0.0])
    bw_array = np.stack([bw_array, bw_array, bw_array], axis=-1).astype(np.uint8)
    result_array = bw_array.copy()
    
    # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —É–∫–∞–∑–∞–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞
    total_mask = np.zeros(img_array.shape[:2], dtype=bool)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º
    if isinstance(colors_to_restore, dict):
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω —Å–ª–æ–≤–∞—Ä—å
        color_items = colors_to_restore.items()
    elif isinstance(colors_to_restore, (list, tuple)):
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω —Å–ø–∏—Å–æ–∫ –∏–ª–∏ –∫–æ—Ä—Ç–µ–∂, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å–ª–æ–≤–∞—Ä—å
        colors_dict = {}
        for i, item in enumerate(colors_to_restore):
            if isinstance(item, dict):
                colors_dict.update(item)
        color_items = colors_dict.items()
    else:
        raise ValueError("colors_to_restore –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–ª–æ–≤–∞—Ä–µ–º –∏–ª–∏ —Å–ø–∏—Å–∫–æ–º/–∫–æ—Ä—Ç–µ–∂–µ–º —Å–ª–æ–≤–∞—Ä–µ–π")
    Smiles = []
    # –ü—Ä–æ–±–µ–≥–∞–µ–º—Å—è –ø–æ –≤—Å–µ–º —ç–ª–µ–º–µ–Ω—Ç–∞–º
    for color_name, target_rgb in color_items:
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ numpy array
        target_rgb = np.array(target_rgb)
        
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–µ–∫—Ç–æ—Ä—ã –¥–ª—è –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞
        img_norm = np.linalg.norm(img_array, axis=2)
        target_norm = np.linalg.norm(target_rgb)
     
        # –°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∏ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ
        dot_product = np.dot(img_array, target_rgb)
        cosine_similarity = dot_product / (img_norm * target_norm + 1e-8)
        
        # –ü–æ—Ä–æ–≥ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞
        mask = cosine_similarity > 0.9
        total_mask = total_mask | mask
        Smiles.append(color_name)
    # –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ –º–∞—Å–∫–∏
    result_array[total_mask] = img_array[total_mask].astype(np.uint8)
    result_img = Image.fromarray(result_array)
    print (f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ SMILES : {Smiles}")
    print (f"–í—Å–µ–≥–æ SMILES : {len(Smiles)}")
    return result_img
    
def painter(picture_path):
    color_data = parse_colors(log_file_name)
    quick_color_restore(picture_path, color_data)
