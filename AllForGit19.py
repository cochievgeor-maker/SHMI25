# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VkowldIhXLoI0RJyPe40v0xlUuFt26BR
"""

import subprocess
import os
import sys
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Draw
import tempfile

def install_xtb():
    """Install xTB in Google Colab"""
    print("Installing xTB...")
    try:
        # Install xTB using conda
        subprocess.run([
            "wget", "https://github.com/grimme-lab/xtb/releases/download/v6.6.0/xtb-6.6.0-linux-x86_64.tar.xz"
        ], check=True)
        subprocess.run(["tar", "-xf", "xtb-6.6.0-linux-x86_64.tar.xz"], check=True)
        subprocess.run(["cp", "-r", "xtb-6.6.0", "/usr/local/"], check=True)
        subprocess.run(["ln", "-sf", "/usr/local/xtb-6.6.0/bin/xtb", "/usr/local/bin/xtb"], check=True)
        subprocess.run(["ln", "-sf", "/usr/local/xtb-6.6.0/lib", "/usr/local/lib/xtb"], check=True)

        # Add to PATH
        os.environ['PATH'] = '/usr/local/xtb-6.6.0/bin:' + os.environ['PATH']
        os.environ['XTBPATH'] = '/usr/local/xtb-6.6.0'

        print("‚úì xTB —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ!")
        return True
    except Exception as e:
        print(f"‚úó –æ—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ xTB: {e}")
        return False
def check_xtb_installation():
    """Check if xTB is installed and available"""
    try:
        result = subprocess.run(["which", "xtb"], capture_output=True, text=True)
        if result.returncode == 0:
            print("‚úì xTB —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
            return True
        else:
            print("xTB –Ω–µ –Ω–∞–π–¥–µ–Ω, —É—Å—Ç–∞–Ω–æ–≤–∫–∞...")
            return install_xtb()
    except Exception as e:
        print(f"Error checking xTB installation: {e}")
        return install_xtb()

def smiles_to_xtb_calculation(smiles, calculation_type='sp', charge=0, spin=1,
                            solvent=None, output_dir="."):
    """
    Convert SMILES to 3D geometry and run xtb calculations

    Parameters:
    - smiles: SMILES string
    - calculation_type: 'sp' for single-point, 'opt' for optimization, 'freq' for frequency
    - charge: molecular charge
    - spin: spin multiplicity (1 for singlet, 2 for doublet, etc.)
    - solvent: solvent for GBSA model (e.g., 'water', 'methanol')
    - output_dir: output directory
    """

    # First check if xTB is installed
    if not check_xtb_installation():
        raise RuntimeError("xTB is not available. Please install it manually.")

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    # Generate molecule from SMILES
    print(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ SMILES: {smiles}")
    mol = Chem.MolFromSmiles(smiles)

    if mol is None:
        raise ValueError(f"–ü–ª–æ—Ö–æ –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π SMILES: {smiles}")

    # Add hydrogens
    mol = Chem.AddHs(mol)

    # Generate 3D coordinates
    print("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç...")
    AllChem.EmbedMolecule(mol, randomSeed=42)

    # Optimize with MMFF94
    print("–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Å MMFF94...")
    AllChem.MMFFOptimizeMolecule(mol)

    # Generate molecule name from SMILES
    mol_name = smiles.replace('/', '_').replace('\\', '_')[:20]

    # Save as XYZ file
    xyz_file = os.path.join(output_dir, f"{mol_name}.xyz")

    # Write XYZ file
    with open(xyz_file, 'w') as f:
        f.write(f"{mol.GetNumAtoms()}\n")
        f.write(f"–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ –∏–∑ SMILES: {smiles}\n")

        conf = mol.GetConformer()
        for i, atom in enumerate(mol.GetAtoms()):
            pos = conf.GetAtomPosition(i)
            symbol = atom.GetSymbol()
            f.write(f"{symbol} {pos.x:.6f} {pos.y:.6f} {pos.z:.6f}\n")

    print(f"–ì–µ–º–µ—Ç—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤: {xyz_file}")

    # Save molecule image
    img_file = os.path.join(output_dir, f"{mol_name}.png")
    img = Draw.MolToImage(mol, size=(300, 300))
    img.save(img_file)
    print(f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –º–æ–ª–µ–∫—É–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ : {img_file}")

    # Display molecule image in Colab
    try:
        from IPython.display import display
        display(img)
    except:
        pass

    # Run xtb calculations
    if calculation_type == 'sp':
        return run_xtb_single_point(xyz_file, charge, spin, solvent, output_dir)
    elif calculation_type == 'opt':
        return run_xtb_optimization(xyz_file, charge, spin, solvent, output_dir)
    elif calculation_type == 'freq':
        return run_xtb_frequency(xyz_file, charge, spin, solvent, output_dir)
    else:
        raise ValueError("calculation_type must be 'sp', 'opt', or 'freq'")

def run_xtb_single_point(xyz_file, charge=0, spin=1, solvent=None, output_dir="."):
    """Run single-point energy calculation"""
    print("–ù–∞—á–∏–Ω–∞–µ–º single-point —Ä–∞—Å—Å—á–µ—Ç —ç–Ω–µ—Ä–≥–∏–∏...")

    # Use list-based command for better security and compatibility
    cmd = ["xtb", os.path.basename(xyz_file), "--sp", "--chrg", str(charge), "--uhf", str(spin-1)]

    if solvent:
        # Fix potential typo in solvent name
        if solvent.lower() == "mathanol":
            solvent = "methanol"
            print(f"Note: Changed solvent from 'mathanol' to 'methanol'")
        cmd.extend(["--gbsa", solvent])

    print(f"Command: {' '.join(cmd)}")

    # Change to output directory and run command
    original_dir = os.getcwd()
    os.chdir(output_dir)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        # Save output
        log_file = "single_point.log"
        with open(log_file, "w") as f:
            f.write(result.stdout)

        if result.returncode == 0:
            print("‚úì Single-point —Ä–∞—Å—Å—á–µ—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã!")
            print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤: {log_file}")
            return parse_xtb_output(result.stdout)
        else:
            print("‚úó Single-point calculation failed!")
            print(f"Error: {result.stderr}")
            # Also print the full output for debugging
            print("Full output:")
            print(result.stdout)
            return None
    finally:
        os.chdir(original_dir)

def run_xtb_optimization(xyz_file, charge=0, spin=1, solvent=None, output_dir="."):
    """Run geometry optimization"""
    print("Running geometry optimization...")

    cmd = ["xtb", os.path.basename(xyz_file), "--opt", "--chrg", str(charge), "--uhf", str(spin-1)]

    if solvent:
        if solvent.lower() == "mathanol":
            solvent = "methanol"
            print(f"Note: Changed solvent from 'mathanol' to 'methanol'")
        cmd.extend(["--gbsa", solvent])

    print(f"Command: {' '.join(cmd)}")

    # Change to output directory and run command
    original_dir = os.getcwd()
    os.chdir(output_dir)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        # Save output
        log_file = "optimization.log"
        with open(log_file, "w") as f:
            f.write(result.stdout)

        if result.returncode == 0:
            print("‚úì Optimization completed!")
            optimized_file = "xtbopt.xyz"
            if os.path.exists(optimized_file):
                print(f"Optimized geometry: {optimized_file}")
            print(f"Output saved to: {log_file}")
            return parse_xtb_output(result.stdout)
        else:
            print("‚úó Optimization failed!")
            print(f"Error: {result.stderr}")
            print("Full output:")
            print(result.stdout)
            return None
    finally:
        os.chdir(original_dir)

def run_xtb_frequency(xyz_file, charge=0, spin=1, solvent=None, output_dir="."):
    """Run frequency calculation"""
    print("Running frequency calculation...")

    cmd = ["xtb", os.path.basename(xyz_file), "--hess", "--chrg", str(charge), "--uhf", str(spin-1)]

    if solvent:
        if solvent.lower() == "mathanol":
            solvent = "methanol"
            print(f"Note: Changed solvent from 'mathanol' to 'methanol'")
        cmd.extend(["--gbsa", solvent])

    print(f"Command: {' '.join(cmd)}")

    # Change to output directory and run command
    original_dir = os.getcwd()
    os.chdir(output_dir)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        # Save output
        log_file = "frequency.log"
        with open(log_file, "w") as f:
            f.write(result.stdout)

        if result.returncode == 0:
            print("‚úì Frequency calculation completed!")
            print(f"Output saved to: {log_file}")
            return parse_xtb_output(result.stdout)
        else:
            print("‚úó Frequency calculation failed!")
            print(f"Error: {result.stderr}")
            print("Full output:")
            print(result.stdout)
            return None
    finally:
        os.chdir(original_dir)

def parse_xtb_output(output):
    """Parse xtb output to extract total energy and HOMO-LUMO gap"""
    results = {}

    lines = output.split('\n')

    for i, line in enumerate(lines):
        # Parse TOTAL ENERGY (from the box at the end)
        if 'TOTAL ENERGY' in line:
            try:
                # Extract energy value from lines like:
                # "| TOTAL ENERGY              -11.393351577127 Eh   |"
                parts = line.split()
                for j, part in enumerate(parts):
                    if part == 'ENERGY':
                        energy_str = parts[j+1]  # Should be the energy value
                        results['total_energy'] = float(energy_str)
                        results['energy_units'] = 'Eh'  # Hartree
                        break
            except (ValueError, IndexError):
                pass

        # Parse HOMO-LUMO GAP (from the box at the end)
        elif 'HOMO-LUMO GAP' in line:
            try:
                # Extract gap value from lines like:
                # "| HOMO-LUMO GAP              12.525947406591 eV   |"
                parts = line.split()
                for j, part in enumerate(parts):
                    if part == 'GAP':
                        gap_str = parts[j+1]  # Should be the gap value
                        results['homo_lumo_gap'] = float(gap_str)
                        results['gap_units'] = 'eV'
                        break
            except (ValueError, IndexError):
                pass

        # Alternative parsing for HOMO-LUMO gap from the orbital section
        elif 'HL-Gap' in line:
            try:
                # Extract from lines like:
                # "HL-Gap            0.4603201 Eh           12.5259 eV"
                parts = line.split()
                # The gap in eV is usually the last numeric value
                for part in reversed(parts):
                    try:
                        gap_value = float(part)
                        # Check if this is likely the eV value (reasonable range for gaps)
                        if 0.1 < gap_value < 50.0:
                            results['homo_lumo_gap'] = gap_value
                            results['gap_units'] = 'eV'
                            break
                    except ValueError:
                        continue
            except (ValueError, IndexError):
                pass

        # Alternative parsing for total energy (from earlier in the output)
        elif 'total energy' in line.lower() and 'total_energy' not in results:
            try:
                # Extract from lines like: "total energy  :        -11.393351577127 Eh"
                parts = line.split()
                for j, part in enumerate(parts):
                    if part.lower() == 'energy':
                        energy_str = parts[j+2]  # Usually two parts after "energy"
                        results['total_energy'] = float(energy_str)
                        results['energy_units'] = parts[j+3]
                        break
            except (ValueError, IndexError):
                pass

    # If we found both values, also calculate the gap in Hartree for consistency
    if 'total_energy' in results and 'homo_lumo_gap' in results:
        # Convert eV to Hartree (1 eV = 0.0367493 Hartree)
        results['homo_lumo_gap_hartree'] = results['homo_lumo_gap'] * 0.0367493

    return results

def run_calculation_interactive(smiles = None):
    """Interactive function for Google Colab - gets input from user"""

    print("=" * 60)
    print("xTB Calculation from SMILES")
    print("=" * 60)
    
    # First check and install xTB if needed
    if not check_xtb_installation():
        print("Failed to install xTB. Please install it manually.")
        return

    # Interactive input for Colab
    # smiles = input("–í–≤–µ–¥–∏—Ç–µ SMILES —Å—Ç—Ä–æ–∫—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, CCO –¥–ª—è —ç—Ç–∞–Ω–æ–ª–∞): ").strip()

    calculation = 'sp'

    charge = 0

    spin = 1

    # solvent = input("Solvent for GBSA model (e.g., water, methanol) [optional]: ").strip()
    # if not solvent:
    solvent = None

    
    output_dir = "./output/" + str(smiles) + "/"
    print (f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—Å—á–µ—Ç–∞ –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {output_dir}")

    try:
        # Run the calculation
        results = smiles_to_xtb_calculation(
            smiles=smiles,
            calculation_type=calculation,
            charge=charge,
            spin=spin,
            solvent=solvent,
            output_dir=output_dir
        )

        # Print results
        if results:
            print("\n" + "="*50)
            print("–†–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")
            print("="*50)
            for key, value in results.items():
                print(f"{key}: {value}")

            # Create a simple summary
            print("\n" + "="*50)
            print("SUMMARY")
            print("="*50)
            if 'total_energy' in results:
                print(f"–û–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è: {results['total_energy']:.6f} {results.get('energy_units', 'Eh')}")
            if 'homo_lumo_gap' in results:
                print(f"HOMO-LUMO –ø–µ—Ä–µ—Ö–æ–¥: {results['homo_lumo_gap']:.4f} {results.get('gap_units', 'eV')}")
            return results
        else:
            print("No results obtained from calculation")

    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()

# For Google Colab compatibility
if __name__ == "__main__":
    # Check if we're in a notebook environment
    try:
        from IPython import get_ipython
        if 'IPKernelApp' in get_ipython().config:
            print("Running in Jupyter/Colab environment")
            # You can call run_calculation_interactive() directly in Colab
    except:
        print("Running in standard Python environment")
        run_calculation_interactive()

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

def gap_to_wavenumber_and_color(gap_hartree):
    """
    –§–∏–∑–∏—á–µ—Å–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ HOMO-LUMO gap:
      1) Hartree ‚Üí eV
      2) eV ‚Üí Œª –ø–æ–≥–ª–æ—â–µ–Ω–∏—è (1250/E)
      3) Œª ‚Üí RGB (–≤–∏–¥–∏–º–∞—è –æ–±–ª–∞—Å—Ç—å)
      4) RGB ‚Üí –∫–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π —Ü–≤–µ—Ç (—Ü–≤–µ—Ç –º–æ–ª–µ–∫—É–ª—ã)
    """

    if gap_hartree <= 0:
        return {
            'gap_hartree': gap_hartree,
            'gap_ev': 0,
            'wavenumber_cm1': 0,
            'wavelength_nm': 0,
            'rgb_color': (0, 0, 0),
            'color_region': 'Invalid',
            'visible': False
        }

    # –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
    EV_PER_HARTREE = 27.211386245988  # —Ç–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    SPEED_OF_LIGHT = 2.99792458e10    # cm/s
    PLANCK_CONSTANT = 6.62607015e-34  # J*s
    HARTREE_TO_J = 4.3597447222071e-18

    # hartree ‚Üí eV
    gap_ev = gap_hartree * EV_PER_HARTREE

    # eV ‚Üí J
    gap_joule = gap_hartree * HARTREE_TO_J

    # ŒΩ = E/h
    frequency_hz = gap_joule / PLANCK_CONSTANT

    # ŒΩ ‚Üí ·πΩ (–≤–æ–ª–Ω–æ–≤–æ–µ —á–∏—Å–ª–æ)
    wavenumber_cm1 = frequency_hz / SPEED_OF_LIGHT

    # Œª (nm) = 1240 / E(eV)
    wavelength_nm = 1240.0 / gap_ev if gap_ev > 0 else 0

    # –¶–≤–µ—Ç –ø–æ–≥–ª–æ—â–µ–Ω–∏—è ‚Üí –≤–∏–¥–∏–º—ã–π –∫–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π
    absorb_rgb = wavelength_to_rgb_piecewise(wavelength_nm)
    visible_rgb = complement_rgb(absorb_rgb)

    # –ö–∞–∫–∞—è —ç—Ç–æ –æ–±–ª–∞—Å—Ç—å?
    if wavelength_nm < 380:
        region = "UV"
        visible = False
    elif wavelength_nm > 780:
        region = "IR"
        visible = False
    else:
        region = "Visible"
        visible = True

    return {
        'gap_hartree': gap_hartree,
        'gap_ev': gap_ev,
        'wavenumber_cm1': wavenumber_cm1,
        'wavelength_nm': wavelength_nm,
        'rgb_color': visible_rgb,
        'color_region': region,
        'visible': visible
    }

import numpy as np

def wavelength_to_rgb_piecewise(wavelength_nm):
    """
    –ü–µ—Ä–µ–≤–æ–¥ –¥–ª–∏–Ω—ã –≤–æ–ª–Ω—ã (–Ω–º) –≤ RGB (0‚Äì255) –¥–ª—è –í–ò–î–ò–ú–û–ì–û —Å–ø–µ–∫—Ç—Ä–∞.
    –í–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ 380‚Äì780 –Ω–º –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (0, 0, 0) –∫–∞–∫ —Ü–≤–µ—Ç —Ñ–æ—Ç–æ–Ω–∞.
    """
    if wavelength_nm < 380 or wavelength_nm > 780:
        return (0, 0, 0)

    wavelength = float(wavelength_nm)

    if 380 <= wavelength <= 440:
        r = -(wavelength - 440) / (440 - 380)
        g = 0.0
        b = 1.0
    elif 440 <= wavelength <= 490:
        r = 0.0
        g = (wavelength - 440) / (490 - 440)
        b = 1.0
    elif 490 <= wavelength <= 510:
        r = 0.0
        g = 1.0
        b = -(wavelength - 510) / (510 - 490)
    elif 510 <= wavelength <= 580:
        r = (wavelength - 510) / (580 - 510)
        g = 1.0
        b = 0.0
    elif 580 <= wavelength <= 645:
        r = 1.0
        g = -(wavelength - 645) / (645 - 580)
        b = 0.0
    elif 645 <= wavelength <= 780:
        r = 1.0
        g = 0.0
        b = 0.0
    else:
        r = g = b = 0.0

    # –ö–æ—Ä—Ä–µ–∫—Ü–∏—è —è—Ä–∫–æ—Å—Ç–∏ –ø–æ –∫—Ä–∞—è–º —Å–ø–µ–∫—Ç—Ä–∞
    if wavelength < 420:
        factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380)
    elif wavelength > 700:
        factor = 0.3 + 0.7 * (780 - wavelength) / (780 - 700)
    else:
        factor = 1.0

    r = int(max(0, min(255, r * factor * 255)))
    g = int(max(0, min(255, g * factor * 255)))
    b = int(max(0, min(255, b * factor * 255)))

    return (r, g, b)


def complement_rgb(rgb):
    """
    –ö–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π —Ü–≤–µ—Ç: —Ç–æ, —á—Ç–æ –º—ã –≤–∏–¥–∏–º –∫–∞–∫ —Ü–≤–µ—Ç –º–æ–ª–µ–∫—É–ª—ã
    (–ø–æ–≥–ª–æ—â—ë–Ω–Ω–æ–µ –≤—ã—á–∏—Ç–∞–µ—Ç—Å—è –∏–∑ –±–µ–ª–æ–≥–æ —Å–≤–µ—Ç–∞).
    """
    r, g, b = rgb
    return (255 - r, 255 - g, 255 - b)


def get_color_with_extended_range(wavelength_nm):
    """
    –û–±—ë—Ä—Ç–∫–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏:
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (rgb, info), –∫–∞–∫ –∏ —Å—Ç–∞—Ä–∞—è –≤–µ—Ä—Å–∏—è.
    rgb ‚Äî –ö–û–ú–ü–õ–ï–ú–ï–ù–¢–ê–†–ù–´–ô —Ü–≤–µ—Ç (–≤–∏–¥–∏–º—ã–π –¥–ª—è –≥–ª–∞–∑–∞),
    info: {'region': ..., 'visible': bool}
    """
    absorb_rgb = wavelength_to_rgb_piecewise(wavelength_nm)
    visible_rgb = complement_rgb(absorb_rgb)

    if wavelength_nm <= 0:
        return visible_rgb, {'region': 'Invalid', 'visible': False}
    elif wavelength_nm < 380:
        return visible_rgb, {'region': 'UV', 'visible': False}
    elif wavelength_nm <= 780:
        return visible_rgb, {'region': 'Visible', 'visible': True}
    else:
        return visible_rgb, {'region': 'IR', 'visible': False}


def gap_to_wavenumber_and_color(gap_hartree):
    """
    –§–∏–∑–∏—á–µ—Å–∫–∏ –æ—Å–º—ã—Å–ª–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ HOMO‚ÄìLUMO gap:
      1) Hartree ‚Üí eV
      2) eV ‚Üí Œª –ø–æ–≥–ª–æ—â–µ–Ω–∏—è
      3) Œª ‚Üí RGB(Œª) –∫–∞–∫ —Ü–≤–µ—Ç –ø–æ–≥–ª–æ—â–µ–Ω–∏—è
      4) –∫–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π RGB ‚Üí —Ü–≤–µ—Ç –º–æ–ª–µ–∫—É–ª—ã
    –§–æ—Ä–º–∞—Ç –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è —Å–æ—Ö—Ä–∞–Ω—ë–Ω, –∫–∞–∫ –≤ —Å—Ç–∞—Ä–æ–π –≤–µ—Ä—Å–∏–∏.
    """

    if gap_hartree is None or gap_hartree <= 0:
        return {
            'gap_hartree': gap_hartree,
            'gap_ev': 0.0,
            'wavenumber_cm1': 0.0,
            'wavelength_nm': 0.0,
            'rgb_color': (0, 0, 0),
            'color_region': 'Invalid',
            'visible': False
        }

    # –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
    EV_PER_HARTREE = 27.211386245988
    HARTREE_TO_JOULE = 4.3597447222071e-18
    PLANCK_CONSTANT = 6.62607015e-34     # –î–∂¬∑—Å
    SPEED_OF_LIGHT_CM = 2.99792458e10    # —Å–º/—Å

    # Hartree ‚Üí eV
    gap_ev = gap_hartree * EV_PER_HARTREE

    # Hartree ‚Üí –î–∂
    gap_joules = gap_hartree * HARTREE_TO_JOULE

    # ŒΩ (–ì—Ü) = E / h
    frequency_hz = gap_joules / PLANCK_CONSTANT

    # –≤–æ–ª–Ω–æ–≤–æ–µ —á–∏—Å–ª–æ ·πΩ (—Å–º‚Åª¬π)
    wavenumber_cm1 = frequency_hz / SPEED_OF_LIGHT_CM

    # Œª (–Ω–º) = 1240 / E(eV)
    wavelength_nm = 1240.0 / gap_ev if gap_ev > 0 else 0.0

    # –¶–≤–µ—Ç –º–æ–ª–µ–∫—É–ª—ã (–∫–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π –∫ —Ü–≤–µ—Ç—É –ø–æ–≥–ª–æ—â–µ–Ω–∏—è)
    rgb_color, info = get_color_with_extended_range(wavelength_nm)

    return {
        'gap_hartree': gap_hartree,
        'gap_ev': gap_ev,
        'wavenumber_cm1': wavenumber_cm1,
        'wavelength_nm': wavelength_nm,
        'rgb_color': rgb_color,
        'color_region': info['region'],
        'visible': info['visible']
    }

def display_single_color(rgb, color_name="Color", size=(5, 2), save_path = None):
    """
    Display a single color with RGB values
    """
    print (f"–¢–≤–æ–π RGB –≤–µ–∫—Ç–æ—Ä - {rgb}")
    # Create figure
    fig, ax = plt.subplots(1, 1, figsize=size)

    # Convert RGB to 0-1 range for matplotlib
    rgb_normalized = [x/255 for x in rgb]

    # Create a simple rectangle with the color
    ax.add_patch(plt.Rectangle((0, 0), 1, 1, color=rgb_normalized))

    # Set up the plot
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_aspect('equal')
    ax.axis('off')

    # Add text with RGB values
    # ax.text(0.5, 0.5, f'–¢–≤–æ–π RGB –≤–µ–∫—Ç–æ—Ä —Ü–≤–µ—Ç–∞ - {rgb}',
    #        ha='center', va='center', fontsize=12,
    #        color='white' if sum(rgb) < 380 else 'black',
    #        weight='bold')
    ax.set_title(f'–¢–≤–æ–π RGB –≤–µ–∫—Ç–æ—Ä —Ü–≤–µ—Ç–∞ - {rgb}', 
             fontsize=10,  # –†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∞
             color='black',  # –¶–≤–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∞
             weight='bold',  # –ñ–∏—Ä–Ω–æ—Å—Ç—å
             pad=20)  # –û—Ç—Å—Ç—É–ø –æ—Ç –≥—Ä–∞—Ñ–∏–∫–∞

    plt.tight_layout()

    if save_path:
        # Create directory if it doesn't exist
        # os.makedirs(os.path.dirname(save_path) if os.path.dirname(save_path) else '.', exist_ok=True)
        # Save the figure
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"–ö–∞—Ä—Ç–∏–Ω–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤: {save_path}")

    plt.show()

def save_name_tuple(name, tuple_data, filename="data.txt"):
    """
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–∞—Ä—É name:tuple –≤ —Ñ–∞–π–ª
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
        if not os.path.exists(filename):
            print(f"–§–∞–π–ª '{filename}' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π.")
        
        with open(filename, 'a', encoding='utf-8') as file:
            file.write(f"{name}: {tuple_data}\n")
        print(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {name}: {tuple_data}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")

def parse_name_tuples(filename="data.txt"):
    """
    –ü–∞—Ä—Å–∏—Ç —Ñ–∞–π–ª –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å {name: tuple}
    """
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –ø–µ—Ä–µ–¥ –ø–∞—Ä—Å–∏–Ω–≥–æ–º
    if not os.path.exists(filename):
        print(f"–§–∞–π–ª '{filename}' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
        return {}
    
    result = {}
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            for line_num, line in enumerate(file, 1):
                line = line.strip()
                if line and ':' in line:
                    name, tuple_str = line.split(':', 1)
                    name = name.strip()
                    tuple_str = tuple_str.strip()
                    
                    # –ü–∞—Ä—Å–∏–º tuple –∏–∑ —Å—Ç—Ä–æ–∫–∏
                    try:
                        import ast
                        parsed_data = ast.literal_eval(tuple_str)
                        if not isinstance(parsed_data, tuple):
                            parsed_data = tuple(parsed_data)
                        result[name] = parsed_data
                    except (ValueError, SyntaxError) as e:
                        print(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ tuple –≤ —Å—Ç—Ä–æ–∫–µ {line_num}: {e}")
                        continue
        return result
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: {e}")
        return {}
        
log_file_name = os.path.join("./", "log.txt")

def homo_lumo_color():
    smiles = input("–í–≤–µ–¥–∏—Ç–µ SMILES —Å—Ç—Ä–æ–∫—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, CCO –¥–ª—è —ç—Ç–∞–Ω–æ–ª–∞): ").strip()
    res = run_calculation_interactive(smiles)
    re = gap_to_wavenumber_and_color(res["homo_lumo_gap_hartree"])

    save_name_tuple(smiles, re['rgb_color'], filename = log_file_name)
    
    display_single_color(re['rgb_color'], save_path = os.path.join("./output/", smiles))
    return re['rgb_color']
# -*- coding: utf-8 -*-
"""Stable Diffusion —Å –≤—ã–±–æ—Ä–æ–º –º–æ–¥–µ–ª–µ–π"""

import torch
import time
import matplotlib.pyplot as plt
from google.colab import files
import gc

# –û—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏
if torch.cuda.is_available():
    torch.cuda.empty_cache()
gc.collect()

# –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
MODELS = {
    "4": {
        "name": "DreamShaper (–£–ù–ò–í–ï–†–°–ê–õ–¨–ù–ê–Ø)",
        "id": "lykon/dreamshaper-8",
        "type": "stable_diffusion"
    }
}

def load_model(model_choice="1"):
    """–ó–∞–≥—Ä—É–∑–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏"""
    model_info = MODELS[model_choice]
    print(f"üöÄ –ó–∞–≥—Ä—É–∑–∫–∞: {model_info['name']}")
    print(f"üìÅ –ú–æ–¥–µ–ª—å: {model_info['id']}")

    try:
        from diffusers import StableDiffusionPipeline

        pipe = StableDiffusionPipeline.from_pretrained(
            model_info["id"],
            torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32,
            safety_checker=None,
            requires_safety_checker=False
        )

        if torch.cuda.is_available():
            pipe = pipe.to("cuda")
            pipe.enable_attention_slicing()
            print("‚úÖ –ú–æ–¥–µ–ª—å –Ω–∞ GPU —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π")
        else:
            pipe = pipe.to("cpu")
            print("‚ö†Ô∏è  –ú–æ–¥–µ–ª—å –Ω–∞ CPU - –±—É–¥–µ—Ç –º–µ–¥–ª–µ–Ω–Ω–æ")

        print(f"‚úÖ {model_info['name']} –∑–∞–≥—Ä—É–∂–µ–Ω–∞!")
        return pipe

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ {model_info['name']}: {e}")
        print("üîÑ –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –±–∞–∑–æ–≤—É—é –º–æ–¥–µ–ª—å...")

        # –ü—Ä–æ–±—É–µ–º –±–∞–∑–æ–≤—É—é –º–æ–¥–µ–ª—å –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
        from diffusers import StableDiffusionPipeline
        pipe = StableDiffusionPipeline.from_pretrained("runwayml/stable-diffusion-v1-5")
        pipe = pipe.to("cuda" if torch.cuda.is_available() else "cpu")
        return pipe



# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ç–µ–∫—É—â–µ–π –º–æ–¥–µ–ª–∏
pipe = None

def initialize_generator():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —Å –≤—ã–±–æ—Ä–æ–º –º–æ–¥–µ–ª–∏"""
    global pipe

    while True:
        choice = "4".strip()

        if choice in MODELS:
            pipe = load_model(choice)
            if pipe is not None:
                return
        else:
            print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")

def generate_with_progress(prompt, steps=20):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º"""
    global pipe

    if pipe is None:
        print("‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞! –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞.")
        return None

    print(f"üé® –ó–∞–ø—Ä–æ—Å: '{prompt}'")
    print(f"üî¢ –®–∞–≥–æ–≤: {steps}")
    print("‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è...", end=" ")

    start_time = time.time()

    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    result = pipe(
        prompt=prompt,
        num_inference_steps=steps,
        guidance_scale=7.5,
        width=512,
        height=512
    )

    end_time = time.time()
    generation_time = end_time - start_time

    print(f"‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {generation_time:.1f} —Å–µ–∫—É–Ω–¥")

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å –∏–º–µ–Ω–µ–º –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    filename = input("üíæ –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–±–µ–∑ .png): ").strip()
    if not filename:
        filename = f"image_{int(time.time())}"

    filename += ".png"
    result.images[0].save(filename)
    print(f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫: {filename}")

    return result.images[0]

# –ü—Ä–∏–º–µ—Ä—ã –ø—Ä–æ–º–ø—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
EXAMPLE_PROMPTS = {
    "4": [
        "—Ñ—ç–Ω—Ç–µ–∑–∏–π–Ω—ã–π –ø–µ–π–∑–∞–∂ —Å –¥—Ä–∞–∫–æ–Ω–æ–º –∏ –∑–∞–º–∫–æ–º, —ç–ø–∏—á–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ",
        "–∞–Ω–∏–º–µ –¥–µ–≤—É—à–∫–∞ —Å —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–º–∏ –≤–æ–ª–æ—Å–∞–º–∏ –≤ –º–∞–≥–∏—á–µ—Å–∫–æ–º –ª–µ—Å—É",
        "–∫–∏–±–µ—Ä–ø–∞–Ω–∫ —É–ª–∏—Ü–∞ –Ω–æ—á—å—é, –¥–æ–∂–¥—å, –Ω–µ–æ–Ω–æ–≤–∞—è —Ä–µ–∫–ª–∞–º–∞"
    ]
}

def main_interface():
    """–ì–ª–∞–≤–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–æ–≥—Ä–∞–º–º—ã"""
    global pipe

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏
    initialize_generator()

    current_model = None
    for key, model in MODELS.items():
        if "dreamshaper" in model["id"].lower() and isinstance(pipe, type(pipe)):
            current_model = key
            break

    if current_model is None:
        current_model = "1"

    print(f"\n‚ú® –¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å: {MODELS[current_model]['name']}")

    while True:
        print("\n" + "="*40)
        print("üé® –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ")
        print("="*40)

        choice = input(
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\n"
            "1 - –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n"
            "2 - –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∏–º–µ—Ä—ã –¥–ª—è —Ç–µ–∫—É—â–µ–π –º–æ–¥–µ–ª–∏\n"
            "3 - –í—ã—Ö–æ–¥\n"
            "> "
        ).strip()

        if choice == "1":
            prompt = input("üìù –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ").strip()
            if not prompt:
                print("‚ùå –û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
                continue

            try:
                steps = int(input("üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ (–æ—Ç 15): ") or "20")
                steps = max(15, steps)
            except:
                steps = 20

            image = generate_with_progress(prompt, steps)

            if image:
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                plt.figure(figsize=(10, 8))
                plt.imshow(image)
                plt.axis('off')
                plt.title(f'"{prompt}"', pad=20)
                plt.tight_layout()
                plt.show()



        elif choice == "2":
            print(f"\nüöÄ –ü—Ä–∏–º–µ—Ä—ã –¥–ª—è {MODELS[current_model]['name']}:")
            for i, example in enumerate(EXAMPLE_PROMPTS[current_model], 1):
                print(f"{i}. {example}")


        elif choice == "3":
            print("üëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!")
            break

        else:
            print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä")

import numpy as np
from PIL import Image
from IPython.display import display

def quick_color_restore(image_path, colors_to_restore):
    """
    –ë—ã—Å—Ç—Ä–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ü–≤–µ—Ç–æ–≤ –∑–∞ –æ–¥–∏–Ω —Ä–∞–∑
    
    Args:
        image_path (str): –ø—É—Ç—å –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
        colors_to_restore (dict): —Å–ª–æ–≤–∞—Ä—å —Å —Ü–≤–µ—Ç–∞–º–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –∏–º—è:–∫–æ—Ä—Ç–µ–∂_RGB
    """
    original_img = Image.open(image_path).convert('RGB')
    img_array = np.array(original_img)
    
    # –°–æ–∑–¥–∞–µ–º —á–µ—Ä–Ω–æ-–±–µ–ª—É—é –≤–µ—Ä—Å–∏—é
    bw_array = np.dot(img_array[...,:3], [0.0, 0.0, 0.0])
    bw_array = np.stack([bw_array, bw_array, bw_array], axis=-1).astype(np.uint8)
    result_array = bw_array.copy()
    
    # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —É–∫–∞–∑–∞–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞
    total_mask = np.zeros(img_array.shape[:2], dtype=bool)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º
    if isinstance(colors_to_restore, dict):
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω —Å–ª–æ–≤–∞—Ä—å
        color_items = colors_to_restore.items()
    elif isinstance(colors_to_restore, (list, tuple)):
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω —Å–ø–∏—Å–æ–∫ –∏–ª–∏ –∫–æ—Ä—Ç–µ–∂, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å–ª–æ–≤–∞—Ä—å
        colors_dict = {}
        for i, item in enumerate(colors_to_restore):
            if isinstance(item, dict):
                colors_dict.update(item)
        color_items = colors_dict.items()
    else:
        raise ValueError("colors_to_restore –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–ª–æ–≤–∞—Ä–µ–º –∏–ª–∏ —Å–ø–∏—Å–∫–æ–º/–∫–æ—Ä—Ç–µ–∂–µ–º —Å–ª–æ–≤–∞—Ä–µ–π")
    Smiles = []
    # –ü—Ä–æ–±–µ–≥–∞–µ–º—Å—è –ø–æ –≤—Å–µ–º —ç–ª–µ–º–µ–Ω—Ç–∞–º
    for color_name, target_rgb in color_items:
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ numpy array
        target_rgb = np.array(target_rgb)
        
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–µ–∫—Ç–æ—Ä—ã –¥–ª—è –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞
        img_norm = np.linalg.norm(img_array, axis=2)
        target_norm = np.linalg.norm(target_rgb)
     
        # –°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∏ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ
        dot_product = np.dot(img_array, target_rgb)
        cosine_similarity = dot_product / (img_norm * target_norm + 1e-8)
        
        # –ü–æ—Ä–æ–≥ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞
        mask = cosine_similarity > 0.9
        total_mask = total_mask | mask
        Smiles.append(color_name)
    # –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ –º–∞—Å–∫–∏
    result_array[total_mask] = img_array[total_mask].astype(np.uint8)
    result_img = Image.fromarray(result_array)
    print (f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ SMILES : {Smiles}")
    print (f"–í—Å–µ–≥–æ SMILES : {len(Smiles)}")
    display(result_img)
    return result_img
    
def painter(picture_path):
    color_data = parse_name_tuples(log_file_name)
    return quick_color_restore(picture_path, color_data)
